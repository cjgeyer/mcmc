
R version 3.3.3 (2017-03-06) -- "Another Canoe"
Copyright (C) 2017 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> 
>  library(mcmc)
> 
>  options(digits=4) # avoid rounding differences
> 
>  set.seed(42)
> 
>  save.initial.seed <- .Random.seed
> 
>  d <- 3
>  witch.which <- 1 - (1 / 2)^(1 / d) * (1 / 4)^(seq(0, 5) / d)
>  witch.which
[1] 0.2063 0.5000 0.6850 0.8016 0.8750 0.9213
> 
>  ncomp <- length(witch.which)
> 
>  neighbors <- matrix(FALSE, ncomp, ncomp)
>  neighbors[row(neighbors) == col(neighbors) + 1] <- TRUE
>  neighbors[row(neighbors) == col(neighbors) - 1] <- TRUE
>  neighbors[row(neighbors) == col(neighbors) + 2] <- TRUE
>  neighbors[row(neighbors) == col(neighbors) - 2] <- TRUE
> 
>  ludfun <- function(state) {
+      stopifnot(is.numeric(state))
+      stopifnot(length(state) == d + 1)
+      icomp <- state[1]
+      stopifnot(icomp == as.integer(icomp))
+      stopifnot(1 <= icomp && icomp <= ncomp)
+      theta <- state[-1]
+      if (any(abs(theta) > 1.0)) return(-Inf)
+      bnd <- witch.which[icomp]
+      if(bnd >= 1.0)
+          stop(sprintf("witch.which[%d] >= 1.0", icomp))
+      if(bnd <= 0.0)
+          stop(sprintf("witch.which[%d] <= 0.0", icomp))
+      if (all(abs(theta) > bnd))
+          return(- (d + 1) * log(2) - d * log(1 - bnd))
+      return(- (d + 1) * log(2) - log1p(- (1 - bnd)^d))
+  }
> 
>  thetas <- runif(ncomp * d, min = -1, max = 1)
>  thetas <- matrix(thetas, ncomp, d)
>  out <- temper(ludfun, initial = thetas, neighbors = neighbors, nbatch = 50,
+      blen = 13, nspac = 7, scale = 0.3456789, parallel = TRUE, debug = TRUE)
> 
>  names(out)
 [1] "lud"           "initial"       "neighbors"     "nbatch"       
 [5] "blen"          "nspac"         "scale"         "outfun"       
 [9] "debug"         "parallel"      "initial.seed"  "final.seed"   
[13] "time"          "batch"         "acceptx"       "accepti"      
[17] "initial"       "final"         "which"         "unif.which"   
[21] "state"         "log.hastings"  "unif.hastings" "proposal"     
[25] "acceptd"       "norm"          "unif.choose"   "coproposal"   
> 
>  out$acceptx
[1] 0.6304 0.4744 0.4481 0.2904 0.6278 0.6667
> 
>  out$accepti
       [,1]   [,2]   [,3]   [,4]   [,5]   [,6]
[1,]     NA 0.7213 0.5699     NA     NA     NA
[2,] 0.6768     NA 0.5238 0.4273     NA     NA
[3,] 0.5421 0.6277     NA 0.5670 0.5204     NA
[4,]     NA 0.2115 0.4821     NA 0.3750 0.4659
[5,]     NA     NA 0.6016 0.4242     NA 1.0000
[6,]     NA     NA     NA 0.3800 1.0000     NA
> 
>  ### check that have prob 1 / 2 for corners
> 
>  outfun <- function(state) {
+      stopifnot(is.matrix(state))
+      ncomp <- nrow(state)
+      d <- ncol(state)
+      foo <- sweep(abs(state), 1, witch.which)
+      bar <- apply(foo > 0, 1, all) 
+      return(as.numeric(bar))
+  }
> 
>  out2 <- temper(out, outfun = outfun)
> 
>  colMeans(out2$batch)
[1] 0.5369 0.4000 0.6277 0.6692 0.0800 0.2985
>  apply(out2$batch, 2, sd) / sqrt(out$nbatch)
[1] 0.03797 0.04919 0.05434 0.05711 0.02085 0.05576
> 
>  ### try again
> 
>  out3 <- temper(out2, blen = 103)
> 
>  foo <- cbind(colMeans(out3$batch),
+      apply(out3$batch, 2, sd) / sqrt(out$nbatch))
>  colnames(foo) <- c("means", "MCSE")
>  foo
      means    MCSE
[1,] 0.4926 0.01390
[2,] 0.4682 0.02386
[3,] 0.4126 0.04190
[4,] 0.4858 0.04571
[5,] 0.5551 0.04837
[6,] 0.8398 0.03034
> 
> 
> proc.time()
   user  system elapsed 
  2.288   0.028   2.307 
