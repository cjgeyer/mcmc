
\documentclass[11pt]{article}

\begin{document}

\title{Design Document for Hit and Run Function}

\author{Charles J. Geyer}

\maketitle

The problem is to simulate a distribution having an unnormalized density that
is a convex function on a convex polytope.  The unnormalized density is
provided by the user as an R function of one argument (a numeric vector).
The convex polytope is provided by the user as a finite set
of linear equalities and inequalities (the polytope is the set of points
satisfying them).  The method of simulation is Markov chain Monte Carlo
using the hit and run algorithm.

Before we can simulate we must do a dimension reduction,
finding the dimension of the convex polytope, and finding a coordinate
system in which the convex polytope has full dimension.  We use functions
in the R package \texttt{rcdd}, which does computational geometry.

To explain the computational geometry part, we do an example.
<<d>>=
d <- 10
@
dimensions, we simulated a probability distribution on the integers
1 to $d$.  Suppose we want both the mean and the median to be exactly
$(d + 1) / 2$.
That gives us two inequality constraints.  Suppose
$p$ is the state vector, then the first constraint is
$$
   \sum_{k = 1}^d k p_k = \frac{d + 1}{2}
$$
and the second is 
$$
   \sum_{k = 1}^{\lfloor (d + 1) / 2 \rfloor} p_k
   =
   \sum_{k = \lceil (d + 1) / 2 \rceil}^d p_k
$$
And suppose we want the median absolute deviation to be at least
<<r>>=
r <- floor((d - 1) / 4)
@
That gives us one inequality constraint
$$
   \sum_{k = 1}^{\lfloor (d + 1) / 2 - r \rfloor} p_k
   +
   \sum_{k = \lceil (d + 1) / 2 + r \rceil}^d p_k
   \ge
   \frac{1}{2}
$$
These are in addition to probabilities being nonnegative and summing to one.
We express the equality constraints as $A_1 p = b_1$, where $A_1$ is a matrix
and $b_1$ a vector,
and we express the equality constraints as $A_2 p = b_2$, where $A_2$ is
a matrix, $b_2$ a vector, and the inequality operates componentwise.
<<cons>>=
i <- 1:d
a1 <- rbind(rep(1, d), i, as.numeric(i <= (d + 1) / 2) -
    as.numeric(i >= (d + 1) / 2))
b1 <- c(1, (d + 1) / 2, 0)
a2 <- - diag(d)
b2 <- rep(0, d)
a2 <- rbind(a2, - as.numeric(i <= (d + 1) / 2 - r) -
    as.numeric(i >= (d + 1) / 2 + r))
b2 <- c(b2, - 1 / 2)
@
Now we dump this into \texttt{rcdd}.
<<hrep>>=
library(rcdd)
hrep1 <- makeH(a2, b2, a1, b1)
hrep1
@
The first column is a secret code (1 indicates an equality constraint,
0 indicates an inequality constraint).  The second column is the right-hand
side vector.  The rest of each row is the negative of some row of $A_1$
or $A_2$.

We now do several operations that are not needed for this example but
are needed if we allow the user to input general constraint matrices
and vectors.  First we check that the polytope is indeed bounded.
<<vrep>>=
vrep1 <- scdd(d2q(hrep1))$output
nrow(vrep1) > 0
all(vrep1[ , 1] == "0")
all(vrep1[ , 2] == "1")
@
The three \texttt{TRUE}'s printed above should also be \texttt{TRUE} for
any allowable constraints.  The codes 0 and 1 indicate that all the generators
are points, so the convex polyhedron is the convex hull of the points that
are the rest of the rows of the V-representation.

Then we eliminate redundant constraints from the H-representation.
<<hrep-too>>=
rout <- redundant(d2q(hrep1))
hrep2 <- rout$output
identical(rout$new.position, 1:nrow(hrep1))
@
This \texttt{TRUE} says that there was no point to the \texttt{redundant}
call: nothing needed to be done.  In general, this will be \texttt{FALSE},
so this check is just for this example.

We do, in general, need to make one use of \texttt{vrep1} and that is to
find a point in the relative interior of the polytope.  (Actually, this
turns out to not be useful.  We will actually need \texttt{vrep4} below
do deal with this issue.)
<<ri>>=
v <- vrep1[ , - c(1, 2)]
x <- apply(v, 2, qsum)
x <- qdq(x, rep(as.character(nrow(v)), length(x)))
x <- q2d(x)
x
@

Now we need to deal with equality constraints and inequality constraints
separately.
<<sep>>=
hrep3 <- hrep2[hrep2[ , 1] == "1", ]
hrep4 <- hrep2[hrep2[ , 1] == "0", ]
@

The equality constraints give us the affine hull of the polytope.
<<affine-hull>>=
vrep3 <- scdd(hrep3, rep = "H")$output
vrep3
is.line <- vrep3[ , 1] == "1" & vrep3[ , 2] == "0"
is.point <- vrep3[ , 1] == "0" & vrep3[ , 2] == "1"
all(is.point | is.line)
sum(is.point) == 1
sum(is.line) == d - nrow(hrep3)
@
The codes in columns 1 and 2 are 0 and 1 (in that order) for a point and
1 and 0 (in that order) for a line.  The affine hull of the convex polytope
is the vector subspace spanned by the points that are linear generators
translated by the point that is a punctate generator.
<<coordinates>>=
foo <- vrep3[ , - c(1, 2)]
origin <- foo[is.point, ]
basis <- foo[is.line, ]
origin <- q2d(origin)
basis <- q2d(basis)
basis <- t(basis)
round(origin, 4)
round(basis, 4)
@
(the transpose is because we want the columns of the matrix \texttt{basis}
to be the basis vectors).
If we denote the vector \texttt{origin} as $u$ and the matrix \texttt{basis}
as $V$, then the transformation $x \mapsto u + V x$ maps
\Sexpr{ncol(basis)}-dimensional space to the affine hull of the convex
polytope considered as an affine subspace of \Sexpr{d}-dimensional
space.

We now need to make the inequality constraints refer to the other coordinate
system.  If the constraints are $A y \le b$, then for the new coordinates,
they are $A(u + V x) \le b$ or $A V x \le b - A u$ so we need to construct
the matrix $A V$ and the vector $b - A u$ to hand to the MCMC algorithm.
<<ineq>>=
amat <- qneg(hrep4[ , - c(1, 2)])
bvec <- hrep4[ , 2]
bvec <- qmq(bvec, qmatmult(amat, cbind(origin)))
amat <- qmatmult(amat, basis)
@
Now we are ready.  If the the unnormalized density function provided by
the user is $h$, then we supply to the hit and run simulator function the
unnormalized density function $h_2 : x \mapsto h(u + V x)$ and the inequality
constraints specified by \texttt{amat} and \texttt{bvec} as calculated above.

Note that the algorithm thinks the state vector is $x$, but the user
thinks the state vector is $u + V x$, so the \texttt{outfun} supplied
to the C function must do this coordinate transformation and if no
\texttt{outfun} is supplied, we must still do this transformation on
the batch means.

Actually, we are almost ready, but need one more step, a point in the
relative interior of the constraint set \emph{in the new coordinates}.
<<hrep5>>=
hrep5 <- cbind("0", bvec, qneg(amat))
vrep5 <- scdd(hrep5, rep = "H")$output
v <- vrep5[ , - c(1, 2)]
x <- apply(v, 2, qsum)
x <- qdq(x, rep(as.character(nrow(v)), length(x)))
@
This \texttt{x} is a possible starting value for the Markov chain.
@
Now we convert the arguments to the MCMC function to conventional
computer so-called real numbers.
<<convert>>=
bvec <- q2d(bvec)
amat <- q2d(amat)
x <- q2d(x)
amat
bvec
round(x, 4)
@

How does hit and run work?  It generates a random direction (we use the
direction along a standard normal random vector), then calculates the
section of the line through the current position in that direction that
lies in the constraint set (the constraint set in the new coordinates
determined by \texttt{amat} and \texttt{bvec}).  That is, we want to know
the maximum and minimum values of $s$ such that
$$
   A (x + s z) \le b
$$
holds where $x$ is the current position and $z$ is the standard normal
random vector.  Since this is the same as
$$
   s A z \le b - A x
$$
we find the range of $s$ values such that this holds.

\end{document}

