
R version 2.15.0 (2012-03-30)
Copyright (C) 2012 The R Foundation for Statistical Computing
ISBN 3-900051-07-0
Platform: i686-pc-linux-gnu (32-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> 
>  library(mcmc)
> 
>  options(digits=4) # avoid rounding differences
> 
>  set.seed(42)
> 
>  d <- 3
>  witch.which <- 1 - (1 / 2)^(1 / d) * (1 / 4)^(seq(0, 5) / d)
>  witch.which
[1] 0.2063 0.5000 0.6850 0.8016 0.8750 0.9213
> 
>  ncomp <- length(witch.which)
> 
>  neighbors <- matrix(FALSE, ncomp, ncomp)
>  neighbors[row(neighbors) == col(neighbors) + 1] <- TRUE
>  neighbors[row(neighbors) == col(neighbors) - 1] <- TRUE
>  neighbors[row(neighbors) == col(neighbors) + 2] <- TRUE
>  neighbors[row(neighbors) == col(neighbors) - 2] <- TRUE
> 
>  ludfun <- function(state) {
+      stopifnot(is.numeric(state))
+      stopifnot(length(state) == d + 1)
+      icomp <- state[1]
+      stopifnot(icomp == as.integer(icomp))
+      stopifnot(1 <= icomp && icomp <= ncomp)
+      theta <- state[-1]
+      if (any(abs(theta) > 1.0)) return(-Inf)
+      bnd <- witch.which[icomp]
+      if(bnd >= 1.0)
+          stop(sprintf("witch.which[%d] >= 1.0", icomp))
+      if(bnd <= 0.0)
+          stop(sprintf("witch.which[%d] <= 0.0", icomp))
+      if (all(abs(theta) > bnd))
+          return(- (d + 1) * log(2) - d * log(1 - bnd))
+      return(- (d + 1) * log(2) - log1p(- (1 - bnd)^d))
+  }
> 
>  thetas <- matrix(0, ncomp, d)
>  out <- temper(ludfun, initial = thetas, neighbors = neighbors, nbatch = 50,
+      blen = 13, nspac = 7, scale = 0.3456789, parallel = TRUE)
> 
>  names(out)
 [1] "lud"          "initial"      "neighbors"    "nbatch"       "blen"        
 [6] "nspac"        "scale"        "outfun"       "debug"        "parallel"    
[11] "initial.seed" "final.seed"   "time"         "batch"        "acceptx"     
[16] "accepti"      "initial"      "final"       
> 
>  out$acceptx
[1] 0.6516 0.3924 0.3465 0.2084 0.1928 0.5874
> 
>  out$accepti
       [,1]   [,2]   [,3]   [,4]   [,5]   [,6]
[1,]     NA 0.6651 0.4608     NA     NA     NA
[2,] 0.6346     NA 0.5397 0.2984     NA     NA
[3,] 0.4796 0.5714     NA 0.4149 0.1031     NA
[4,]     NA 0.1980 0.3193     NA 0.2621 0.3137
[5,]     NA     NA 0.1871 0.2609     NA 0.2615
[6,]     NA     NA     NA 0.3333 0.3174     NA
> 
>  ### check that have prob 1 / 2 for corners
> 
>  outfun <- function(state) {
+      stopifnot(is.matrix(state))
+      ncomp <- nrow(state)
+      d <- ncol(state)
+      foo <- sweep(abs(state), 1, witch.which)
+      bar <- apply(foo > 0, 1, all) 
+      return(as.numeric(bar))
+  }
> 
>  out <- temper(out, outfun = outfun)
> 
>  colMeans(out$batch)
[1] 0.5492 0.4800 0.5569 0.7692 0.9246 0.7708
>  apply(out$batch, 2, sd) / sqrt(out$nbatch)
[1] 0.03585 0.05019 0.05510 0.04775 0.02586 0.05737
> 
>  ### try again
> 
>  out <- temper(out, blen = 103, outfun = outfun)
> 
>  foo <- cbind(colMeans(out$batch),
+      apply(out$batch, 2, sd) / sqrt(out$nbatch))
>  colnames(foo) <- c("means", "MCSE")
>  foo
      means    MCSE
[1,] 0.5033 0.01345
[2,] 0.5122 0.02469
[3,] 0.4969 0.03692
[4,] 0.5283 0.04713
[5,] 0.4583 0.04743
[6,] 0.4192 0.05931
> 
> 
> proc.time()
   user  system elapsed 
  5.452   0.048   5.485 
